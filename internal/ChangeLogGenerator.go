package internal

import (
	"bytes"
	"encoding/json"
	"fmt"
	"golang.org/x/exp/maps"
	"io"
	"io/ioutil"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
)

var (
	subjectRegex = regexp.MustCompile("(?P<type>feat|fix|doc|chore|refactor|test|style|perf|other)(\\((?P<issue>[^)]+)\\))?: (?P<message>.*)")
	l            = log.New(os.Stdout, "[ChangeLogGenerator] ", log.LstdFlags)
)

type (
	// ChangeLogGenerator allows creates a changelog for a list of commit subjects
	ChangeLogGenerator struct {
		/* input */

		// reader is where to get the subjects lines from
		reader io.Reader

		/* configuration */

		// Groups maps a type name to a group name
		Groups map[string]string `json:"groups"`
		// Header text that will be added to the beginning of the changelog
		Header string `json:"header"`
		// Footer text that will be added to the end of the changelog
		Footer string `json:"footer"`
		// BodyTemplate, represents a single release in the changelog
		BodyTemplate string `json:"body_template"`
		// LinkParsers are a collection of parser configs
		LinkParsers []LinkParsingData `json:"link_parsers"`

		/* runtime stuff */
		// version is used to store the provided version
		version string
		// printConfiguration prints out the configuration
		printConfiguration bool
		// configuration if provided
		configuration *ChangeLogGenerator

		// lines passed to the tool
		lines []string
		// commits Groups parsed lines
		commits map[string][]*Commit
		// bodyTemplate is the instantiated template
		bodyTemplate *template.Template
		// changelogTemplate is the overall document
		changelogTemplate *template.Template
	}

	// LinkParsingData contains information to apply a match and replace
	// on issues for example
	LinkParsingData struct {
		// Pattern with one group to test for
		Pattern string `json:"pattern"`
		// Href with one string replacement for group from pattern
		Href string `json:"href"`
		// Text for link with max one string replacement
		Text string `json:"text"`

		// regex is the compiled regex
		regex *regexp.Regexp
	}

	// changeLogData is passed to changelogTemplate as data
	changeLogData struct {
		// Header text that will be added to the beginning of the changelog
		Header string
		// Footer text that will be added to the end of the changelog
		Footer string
		// Body is the list of commits processed with the body template
		Body string
	}

	// Commit represents one commit subject line
	Commit struct {
		// Type of commit (e.g. feat)
		Type string
		// Scope of commit or issue
		Scope string
		// Subject og commit
		Subject string
	}

	// ChangeLogGeneratorOption can be used to change options
	ChangeLogGeneratorOption func(generator *ChangeLogGenerator)
)

// NewChangeLogGenerator returns a changelog generator
func NewChangeLogGenerator(reader io.Reader, options ...ChangeLogGeneratorOption) (*ChangeLogGenerator, error) {
	clg := &ChangeLogGenerator{
		reader: reader,
		lines:  make([]string, 0),
		Groups: map[string]string{
			"feat":     "Feature",
			"fix":      "Bugfix",
			"doc":      "Other",
			"chore":    "Other",
			"refactor": "Optimization",
			"test":     "Optimization",
			"style":    "Usability",
			"perf":     "Optimization",
			"other":    "Other",
		},
		commits: make(map[string][]*Commit),
		BodyTemplate: `{{ range $index, $element := . }}## {{ $index }}{{ range $val := $element }}
- {{ $val.Subject }}{{ if $val.Scope }} ({{ $val.Scope }}){{ end }}{{ end }}

{{ end }}`,
		Header: "# Changelog",
		Footer: "generated by git-cl",
	}
	var err error
	clg.changelogTemplate, err = template.New("clt").Parse(`{{ .Header }}

{{ .Body }}{{ .Footer }}`)
	if err != nil {
		return nil, err
	}

	clg.LinkParsers = append(clg.LinkParsers, LinkParsingData{
		Pattern: "#(\\d+)",
		Href:    "https://github.com/username/project/issues/%s",
		Text:    "Link to GitHub issue %s",
	})

	clg.LinkParsers = append(clg.LinkParsers, LinkParsingData{
		Pattern: "RFC(\\d+)",
		Href:    "https://datatracker.ietf.org/doc/html/rfc%s",
		Text:    "ietf-rfc%s",
	})

	for _, opt := range options {
		if nil == opt { // quirk when using functional options, it is possible to pass nil
			continue
		}
		opt(clg)
	}

	if clg.printConfiguration {
		return clg, nil
	}

	err = clg.applyConfiguration()
	if err != nil {
		return nil, err
	}

	return clg, clg.readSubjectLines()
}

// applyConfiguration adds configuration data from passed configuration option
func (clg *ChangeLogGenerator) applyConfiguration() (err error) {
	if clg.configuration == nil {
		return
	}

	if clg.configuration.Header != "" {
		clg.Header = clg.configuration.Header
	}
	if clg.configuration.Footer != "" {
		clg.Footer = clg.configuration.Footer
	}
	if clg.configuration.BodyTemplate != "" {
		clg.BodyTemplate = clg.configuration.BodyTemplate
	}
	for key, value := range clg.configuration.Groups {
		hasKey := false
		for _, k := range maps.Keys(clg.Groups) {
			hasKey = k == key
			if hasKey {
				break
			}
		}
		if !hasKey {
			err = fmt.Errorf("no such type: %s", key)
			return
		}
		clg.Groups[key] = value
	}
	if nil != clg.configuration.LinkParsers {
		clg.LinkParsers = clg.configuration.LinkParsers
	}
	return
}

// readSubjectLines gets all lines from reader, called from NewChangeLogGenerator
func (clg *ChangeLogGenerator) readSubjectLines() error {
	data, err := ioutil.ReadAll(clg.reader)
	if err != nil {
		return err
	}
	clg.lines = strings.Split(string(data), "\n")
	return nil
}

// OverrideGroupForType allows changing the group for a type
func (clg *ChangeLogGenerator) OverrideGroupForType(typeName, group string) {
	if _, ok := clg.Groups[typeName]; ok {
		clg.Groups[typeName] = group
	}
}

// Build runs through the list of provided commit messages and creates the MarkDown output
func (clg *ChangeLogGenerator) Build() (result string, err error) {
	result = ""

	if clg.printConfiguration {
		data, innerError := json.Marshal(clg)
		if innerError != nil {
			err = innerError
			return
		}
		var indented bytes.Buffer
		err = json.Indent(&indented, data, "", "\t")
		if err != nil {
			return
		}
		result = indented.String()
		return
	}

	err = clg.loadChangeLogEntryTemplate()
	clg.parseAndGroupCommits()
	clg.applyLinkParser()
	clg.capitalizeSubjects()

	result, err = clg.generateOutput()
	return
}

func (clg *ChangeLogGenerator) applyLinkParser() {
	for i := range clg.LinkParsers {
		clg.LinkParsers[i].regex = regexp.MustCompile(clg.LinkParsers[i].Pattern)
	}
	for s := range clg.commits {
		for i := range clg.commits[s] {
			for _, parser := range clg.LinkParsers {
				subj := clg.commits[s][i].Subject
				if parser.regex.MatchString(subj) {
					matches := parser.regex.FindStringSubmatch(subj)
					title := matches[0]
					if parser.Text != "" {
						title = fmt.Sprintf(parser.Text, matches[1])
					}
					clg.commits[s][i].Subject = strings.Replace(clg.commits[s][i].Subject, matches[0], fmt.Sprintf("[%s](%s)", title, fmt.Sprintf(parser.Href, matches[1])), -1)
				}
				subj = clg.commits[s][i].Scope
				if parser.regex.MatchString(subj) {
					matches := parser.regex.FindStringSubmatch(subj)
					title := matches[0]
					if parser.Text != "" {
						title = fmt.Sprintf(parser.Text, matches[1])
					}
					clg.commits[s][i].Scope = strings.Replace(clg.commits[s][i].Scope, matches[0], fmt.Sprintf("[%s](%s)", title, fmt.Sprintf(parser.Href, matches[1])), -1)
				}
			}

			clg.commits[s][i].Subject = strings.ToUpper(clg.commits[s][i].Subject[0:1]) + clg.commits[s][i].Subject[1:]
		}
	}
}

// capitalizeSubjects is used to turn =the first character to upper case
func (clg *ChangeLogGenerator) capitalizeSubjects() {
	for s := range clg.commits {
		for i := range clg.commits[s] {
			clg.commits[s][i].Subject = strings.ToUpper(clg.commits[s][i].Subject[0:1]) + clg.commits[s][i].Subject[1:]
		}
	}
}

// parseAndGroupCommits
func (clg *ChangeLogGenerator) parseAndGroupCommits() {
	for _, line := range clg.lines {
		if !subjectRegex.MatchString(line) {
			continue
		}
		matches := subjectRegex.FindStringSubmatch(line)
		groupNames := subjectRegex.SubexpNames()
		commit := &Commit{}
		for i, match := range matches {
			if groupNames[i] == "type" {
				commit.Type = match
			}
			if groupNames[i] == "message" {
				commit.Subject = match
			}
			if groupNames[i] == "issue" {
				commit.Scope = match
			}
		}
		if len(commit.Subject) == 0 {
			l.Printf("omitting commit (%s), no subject provided", commit)
			continue
		}
		gn := clg.getGroup(commit)
		if gn == "" {
			l.Printf("omitting commit (%s), does not match", commit)
			continue
		}
		if _, ok := clg.commits[gn]; !ok {
			clg.commits[gn] = make([]*Commit, 0)
		}
		clg.commits[gn] = append(clg.commits[gn], commit)
	}
}

// getGroup looks up group for commit
func (clg *ChangeLogGenerator) getGroup(c *Commit) string {
	if gn, ok := clg.Groups[c.Type]; ok {
		return gn
	}
	return ""
}

// loadChangeLogEntryTemplate loads the textually provided template in a template instance
func (clg *ChangeLogGenerator) loadChangeLogEntryTemplate() (err error) {
	clg.bodyTemplate, err = template.New("cle").Parse(clg.BodyTemplate)
	if err != nil {
		l.Printf("error constructing template: %s", err)
		return
	}
	return
}

// generateOutput leverages the templates to generate the changelog
func (clg *ChangeLogGenerator) generateOutput() (result string, err error) {
	wr := bytes.Buffer{}
	err = clg.bodyTemplate.Execute(&wr, clg.commits)

	header := clg.Header
	if clg.version != "" {
		header = fmt.Sprintf("%s %s", header, clg.version)
	}

	cld := &changeLogData{
		Header: header,
		Footer: clg.Footer,
		Body:   string(wr.Bytes()),
	}

	var buf bytes.Buffer
	err = clg.changelogTemplate.Execute(&buf, cld)
	result = buf.String()
	return
}

// String shows a visual representation of a commit
func (c Commit) String() string {
	return fmt.Sprintf("type := %s scope := %s subject := %s", c.Type, c.Scope, c.Subject)
}
